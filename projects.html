<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Projects</title>
<link rel="stylesheet" href="assets/css/air.css">
<script src = "assets/scroll.js"></script>
</head>
<body>
<h3>My Projects</h3>
<div class="hr">
	<hr>
</div>

<font size="6">
<h4><a href="index.html">Home</a></h4>
</font>

<p><strong>
Intractable Problems:<i>The Modified Traveling Salesman Project</i>
</strong>
<img src="assets/images/map.png" alt="The Modified Traveling Salesman Problem">
</p>
This was a project for my Algorithms course: CS170. The project specification can be found <a href="cs170-spec.pdf">here</a>.
<br><br>
<strong>Brief:</strong>
<br>
The project was a modified version of the famous intractable problem: The Traveling Salesman Problem (TSP). Given an input graph where each vertex represents a kingdom, and there exixt edge weights as well as conquering costs for each kingdom; our task was to design and develop an algorithm that <b>conquers all kingdoms (vertices)</b> while minimizing the <i>Total Cost</i> = ∑ Conquering costs + ∑ Traveling costs.

<br>
<ul>The project was trickier than the TSP because of certain special rules that the project allowed:
	<li>Once you conquer a kingdom, all its neighbours are automatically conquered.</li>
	<li>Kingdoms can be visited without conquering them.</li>
	<li>One must begin and end the tour at the starting kingdom given to us.</li>
</ul>
<br>
<strong>The algorithm:</strong>
<ul>We utilized a two-part approach to derive a solution given an input instance:
	<li><b>Finding the set of <i>special</i> nodes to conquer</b></li>
	We used a greedy strategy with multiple heuristics to approximate the minimum weighted set cover (i.e. given a graph with vertex weights, finding the minimum weight that covers the entire graph). Our heuristics include combinations of max_neighbours, average_edge_cost, min_conquering_cost, et al.
	<li><b>Generating a cheap tour through these special nodes</b></li>
	Once we have determined our set of <i>special</i> nodes, we generate the cheapest possible tour through these subset of vertices. We used a number of approaches to approximate the best possible tour through these vertices:
	<ul>
		<li>Creating a <i>Steiner Tree</i> of the special nodes and running all pairs shortest path to generate a tour from the starting vertex</li>
		<li>Reducing the problem to Metric-TSP by adding heavy-weighted dummy edges to make the graph complete; we then use <i>Christofides</i> algorithm</li>
		<li>We also tried to use a greedy approach by running Dijkstra's algorithm from every special node and greedily adding the closest special node to the tour</li>
	</ul>


<p><strong>Algorithm-centric projects</strong></p>
<ul>
	<li>CS 188, <strong>Artifical Intelligence</strong>, with Peter Abbeel and Dan Klein</li>
	<li>Econ 136, <strong>Financial Economics</strong>, with Raymond Hawkins</li>
	<li>CS 61C, <strong>Computer Architecture</strong>, with Dan Garcia</li>
</ul>

<p><strong>System-based projects</strong></p>
<ul>
	<li>CS 188, <strong>Artifical Intelligence</strong>, with Peter Abbeel and Dan Klein</li>
	<li>Econ 136, <strong>Financial Economics</strong>, with Raymond Hawkins</li>
	<li>CS 61C, <strong>Computer Architecture</strong>, with Dan Garcia</li>
</ul>

</body>
</html>